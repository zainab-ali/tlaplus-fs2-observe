# TLA+ and fs2

This repository is an attempt at modelling the behaviour of the fs2 `observe` primitive in
TLA+.

Specifically, it verifies whether [a simplified implementation of observe](https://github.com/typelevel/fs2/issues/2778) is correct.
The refactored code might contain race conditions, or have different behaviour, that is difficult to work out by eye.

## Getting started

The specification is written in TLA+ and PlusCal. You can get started with these tools by following the instructions on the [Learn TLA+ website](https://www.learntla.com/introduction/).

## Developing a model

A PlusCal process is a series of sequential steps that can be interleaved in a non-deterministic order.

The implementation of `observe` contains several processes:

```scala
  for {                                                                 
    guard <- Semaphore[F](maxQueued - 1)
    outChan <- Channel.unbounded[F, Chunk[O]]
  } yield {
 
    val sinkOut: Stream[F, O] = {
      def go(s: Stream[F, Chunk[O]]): Pull[F, O, Unit] =
        s.pull.uncons1.flatMap { \\ InOutput
          case None => Pull.done
          case Some((ch, rest)) =>
            Pull.output(ch) >>
             Pull.eval(outChan.send(ch) \\ InSendToChannel
                       >> guard.acquire \\ InAcquireGuard
                       ) >>
                    go(rest)
        }
 
      go(self.chunks).stream
    }
 
    val runner =
      sinkOut.through(pipe)             \\ InComplete, ObserverComplete
        .onFinalize(outChan.close.void) \\ ObserverOnFinalize
 
    def outStream =
      outChan.stream \\ OutPopFromChannel
        .flatMap { chunk =>
          Stream.chunk(chunk) \\ OutOutput
            .onFinalize(guard.release) \\ OutReleaseGuard
        }
 
    val out = outStream.concurrently(runner)  \\ OutOnFinalize
    out
```

These can be roughly thought of as the `in`, `out` and `observer` process.

### Steps, state and properties

In order to describe a problem in TLA+ and PlusCal, we must:
 1. Identify the **properties** of the system. 
    
	These are the invariants. For example ”all elements that were
    pulled from the input must have been requested by the output”.

 2. Identify the **steps** of the computation.
 
    These are the atomic units that the evaluator can take when
    interleaving the code.
	
 3. Model the **state** that is changed at each step.

Each step, indicated by a comment in the `observe` code above, is given a label and an associated state change. 
At each step, we can make assertions about the state of the system and verify that it satisfies certain properties (invariants and temporal properties).

The state is a simplified representation of the stream system that we can make these assertions on. For example:
 - The sequence of sent elements 
 - The sequence of received elements
 - The number of elements requested from upstream
 - The exit state of the stream

The `ObserverSpec` describes this state and the assertions made on it.

### Interruptions

The `in` and `out` processes may be interrupted by an external event. For example, an interrupt of the `in` stream may look like:

```scala
in.observe(_.interruptAfter(1.second))
```

An interrupt of the `out` stream may look like:

```scala
in.observe(identity).interruptAfter(1.second)
```

Interruptions can also be represented as single-step PlusCal processes. These processes set flags that other processes can query.

# Properties of `observe`

Any implementation of `observe` should satisfy:
 - If `input` is finite, then `output` terminates
 - If the `input` terminates with an error, then the `output` terminates with an error
 - If the `observer` terminates with an error, then the `output` terminates with an error
 - No more elements are pulled from `input` than are requested by `output`
 - An element is only pulled from `input` if both `observer` and `output` request it
 - The number of elements pulled from `input` is at most one greater than the number of elements requested by `output`
 - If the `input` is finite and the `observer` requests the same number of elements as the `output`, then the `output` and `observer` should both complete.
 - If the `observer` requests more elements than the `output` then it should be cancelled. 
 - If the `output` terminates successfully, then the elements pulled by it should be equal to those pulled from `input`
 - If the `observer` terminates successfully, then the elements pulled by it should be equal to those pulled from `input`
 - If the `observer` cancels itself, then the `output` is cancelled 
 - If the `output` cancels itself, then the `observer` is cancelled. 
 
# Conclusions

1. The refactored code is not exactly the same as the original code.
   The observer may swallow errors generated by the input stream. For example:

   ```scala
   val out = in.observe(_.handleErrorWith(_ => Stream.empty))
   ```
   
   The error is not propagated from the `in` to the `out` stream.

2. Both the refactored and original code violate an invariant: the number of elements sent by the input is not equivalent to the number received by the output, even when the entire system terminates successfully. The observer may request one more element from the input stream than the output. This is actually tested in the `StreamObserveSuite`:

   ```scala
   group("handle finite observing sink") {
     test("2") {
       forAllF { (s: Stream[Pure, Int]) =>
         observer(Stream(1, 2) ++ s.covary[IO])(_.take(1).drain).compile.toList
           .assertEquals(Nil)
       }
     }
   }
   ```

3. On the positive side, the refactored code does terminate in all cases.

# Details

## The observer and input relationship

The observer pipe is written by the user, thus the observer scope may have any sort of relationship to the input scope. This makes error propagation and cancellation difficult to model, as these are dependent on the scope relationship. We will classify the relationship as one of:
 - `OParent`, implying that the observer is a parent of the input. For example, `observer = _.take(3)`
 - `OTransient`, implying that the observer is a parent of the input at some point in time. For example `observer = _ ++ other`
 - `ONone`, implying that the input and observer scopes are unrelated. The input may run concurrently to the observer. We have to assume certain error propagation behaviours in this case.
 
## Error handling in the observer
 
The observer may handle errors in the input with `handleErrorWith`, thus the observer termination state doesn't necessarily reflect the input termination state.

## Assumptions

 1. The effect that creates the `observe` system and starts it concurrently is only created if an element is pulled downstream. Thus, the `out` stream must pull at least one element.
 
	If the system could be started without the output requesting an element then some invariants would be violated, notably the invariants that relate the elements pulled from the input to those received by the output.

 2. The `observer` pipe must clean up resources on the `in` stream. A well-behaved observer must not start the `in` stream in a fiber and forget to cancel it.
 
   This assumption affects the order of steps following `onFinalize(channel.close)`. The `in` stream cannot take steps after the channel has been closed.

 3. The `observer` may run the `in` stream concurrently to itself. Elements may be pulled from the `in` stream independently of any work done in the observer. The `observer` may also cancel the `in` stream while it itself completes successfully.
 
    If the `observer` stream is cancelled, then it must cancel the `in` stream. It does so before closing the channel with `onFinalize(channel.close)`.
